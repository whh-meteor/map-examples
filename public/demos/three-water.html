<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>黄岛海水效果（修复版）</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/maptalks/dist/maptalks.css" />
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            width: 100%;
        }

        #map {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <!-- 加载顺序：maptalks -> three (指定版本) -> maptalks.three -->
    <script src="https://cdn.jsdelivr.net/npm/maptalks/dist/maptalks.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/maptalks.three@0.27.0/dist/maptalks.three.js"></script>

    <script>
        /************************************************************************
         * 修复说明：
         * 1) 顶点着色器不再重新声明 `position`，避免在 WebGL2/three.js 注入时重复定义导致编译失败
         * 2) 鼠标注册改为安全查找 canvas（若未就绪则短暂重试）
         * 3) 保留之前把 Shadertoy 风格 shader 映射到全屏 quad 的思路（方便快速调试 shader）
         ************************************************************************/

        // 地图初始化（黄岛附近）
        const map = new maptalks.Map('map', {
            center: [120.19, 35.96],
            zoom: 13,
            pitch: 0,
            baseLayer: new maptalks.TileLayer('base', {
                urlTemplate: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png',
                subdomains: ['a', 'b', 'c', 'd']
            })
        });

        // three layer
        const threeLayer = new maptalks.ThreeLayer('three', {
            forceRenderOnMoving: true,
            forceRenderOnRotating: true,
            animation: true
        }).addTo(map);

        // Uniforms
        const uniforms = {
            iTime: { value: 0.0 },
            iResolution: { value: new THREE.Vector3(window.innerWidth, window.innerHeight, 1) },
            iMouse: { value: new THREE.Vector4(0, 0, 0, 0) }
        };

        // 顶点着色器：不要重新声明 position，直接使用 three.js 注入的 position
        // 使用 position.xy -> 生成 UV（适用于全屏 quad）
        const vertexShader = `
    varying vec2 vUv;
    void main() {
      // position 由 three.js 注入，直接使用
      vUv = position.xy * 0.5 + 0.5;
      gl_Position = vec4(position, 1.0);
    }
  `;

        // 片元着色器：示例 Shadertoy 风格的简化版本（无版本指令，兼容三.js 自动处理）
        // 你可以把完整的 Shadertoy 函数逐步替换到这里（注意兼容性）
        const fragmentShader = `
    precision highp float;
    uniform float iTime;
    uniform vec3 iResolution;
    uniform vec4 iMouse;
    varying vec2 vUv;

    // 简单噪声 + 波动演示（占位，可替换为完整 Shadertoy 代码）
    float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
    float noise(vec2 p){
      vec2 i = floor(p);
      vec2 f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      vec2 u = f*f*(3.0-2.0*f);
      return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
    }

    void main() {
      // 把 vUv 映射为 fragCoord 风格
      vec2 fragCoord = vUv * iResolution.xy;

      // 生成一些层叠噪声作为波纹效果
      vec2 p = fragCoord / iResolution.y * 3.0; // 保持纵横比
      float n = 0.0;
      float amp = 0.5;
      for (int i=0;i<4;i++){
        n += noise(p) * amp;
        p *= 2.0;
        amp *= 0.5;
      }

      // 颜色混合（蓝色海面基色）
      vec3 col = mix(vec3(0.02,0.08,0.25), vec3(0.15,0.45,0.85), clamp(n, 0.0, 1.0));

      // 简单波光随时间变化
      col += 0.06 * sin(iTime*1.4 + fragCoord.y*0.02 + n*6.3);

      gl_FragColor = vec4(col, 0.95);
    }
  `;

        // 创建全屏 quad 几何体（直接在 NDC 空间构建）
        const geom = new THREE.BufferGeometry();
        const verts = new Float32Array([
            -1, -1, 0,
            1, -1, 0,
            1, 1, 0,
            -1, -1, 0,
            1, 1, 0,
            -1, 1, 0
        ]);
        geom.setAttribute('position', new THREE.BufferAttribute(verts, 3));

        // 材质
        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms,
            transparent: true,
            depthTest: false
        });

        const quad = new THREE.Mesh(geom, material);

        // 把 quad 添加到 three 场景（在 prepareToDraw 中）
        threeLayer.prepareToDraw = function (gl, scene, camera) {
            // 确保只添加一次
            if (!this._quadAdded) {
                scene.add(quad);
                this._quadAdded = true;
            }
            // 更新 iResolution 为 canvas 大小
            const canvas = this.getRenderer() && this.getRenderer().domElement;
            if (canvas) {
                uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
            } else {
                // 兜底为窗口尺寸
                uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
            }
        };

        // 动画循环：更新时间并触发 threeLayer 重绘
        const clock = new THREE.Clock();
        (function animate() {
            requestAnimationFrame(animate);
            uniforms.iTime.value = clock.getElapsedTime();
            threeLayer.redraw();
        })();

        // 安全注册鼠标：尝试获取 canvas，若未就绪则短延迟重试（避免读取 undefined.style 错误）
        (function registerMouseSafe(retries = 0) {
            const canvas = document.querySelector('canvas');
            if (!canvas) {
                if (retries < 10) {
                    // 非阻塞短延迟后重试（浏览器会在三层初始化后创建 canvas）
                    return setTimeout(() => registerMouseSafe(retries + 1), 120);
                }
                return; // 放弃注册（极少数情况下）
            }
            // 注册事件（把鼠标位置传入 uniforms.iMouse）
            canvas.style.touchAction = 'none';
            function setMouse(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                // 这里把 y 翻转成 shadertoy 风格（左下为原点）
                uniforms.iMouse.value.set(x, rect.height - y, x, rect.height - y);
            }
            window.addEventListener('mousemove', setMouse);
            window.addEventListener('mousedown', setMouse);
        })();

        // 窗口尺寸变化同步 iResolution 并重新渲染
        window.addEventListener('resize', function () {
            const canvas = document.querySelector('canvas');
            if (canvas) {
                uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
            } else {
                uniforms.iResolution.value.set(window.innerWidth, window.innerHeight, 1);
            }
            threeLayer.redraw();
        });

    </script>
</body>

</html>